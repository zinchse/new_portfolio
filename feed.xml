<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://zinchse.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://zinchse.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-06-25T05:47:58+00:00</updated><id>https://zinchse.github.io/feed.xml</id><title type="html">blank</title><subtitle>Sergey Zinchenko&apos;s portfolio site
</subtitle><entry><title type="html">Yandex Training 3.0 - Hints and Results</title><link href="https://zinchse.github.io/blog/2023/yandex-training/" rel="alternate" type="text/html" title="Yandex Training 3.0 - Hints and Results" /><published>2023-06-22T13:59:00+00:00</published><updated>2023-06-22T13:59:00+00:00</updated><id>https://zinchse.github.io/blog/2023/yandex-training</id><content type="html" xml:base="https://zinchse.github.io/blog/2023/yandex-training/"><![CDATA[<p><img src="/assets/img/contest_logo.png" alt="contest logo" width="800px" /></p>

<blockquote>
  <p>Path <strong>from</strong> <em>“count the number of characters”</em>  <strong>to</strong>  <em>“compress graph by going to graph on connected components, build common transitive vertex to reduce number of edges, set problem on state graph and solve it bypassing 0-1 BFS”</em> <br />
– or just <a href="https://yandex.ru/yaintern/algorithm-training"><code class="language-plaintext highlighter-rouge">[Yandex.Training 3.0]</code></a> :D</p>
</blockquote>

<p>I’ve already seen most of the problems from there in some form, but I really liked the last block. The concept of the <code class="language-plaintext highlighter-rouge">State Graph</code> is very cool, I recommend everyone to get acquainted.
You can find my solutions and the template with optimal and universal I/O <a href="https://github.com/zinchse/_contests">[here]</a>.</p>

<p>As a result, I took <code class="language-plaintext highlighter-rouge">1-144</code>th place in the olympiad division, and was the first among those who were left without prizes, both in the both divisions. Interestingly, I wrote an algorithm with optimal asymptotics, which did not pass all the tests, and most of the time I tried to start it. But without success… So, after a couple of months I got back to this problem, and found something amazing (<code class="language-plaintext highlighter-rouge">really :)</code>). About this I will report in a separate post.</p>

<p>The main experience that I took away from these trainings:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Input/Output</code> is an important part of the problem</strong>
    <blockquote>
      <p>you have to think about how fast you read and write data; to combat this problem, I wrote a special <a href="https://github.com/zinchse/_contests/blob/main/yandex%20training%203.0/template.py">[template]</a> in which you need to organize only one function <code class="language-plaintext highlighter-rouge">solve</code>, the data is processed by other methods in an optimal way</p>
    </blockquote>
  </li>
  <li><strong>the problem’s input limits are the most important information in the problem’s definition</strong>
    <blockquote>
      <p>you can use them to figure out the asymptotic required solution; my advice is to assume that python can handle <code class="language-plaintext highlighter-rouge">10 ** 7</code> operations; then a solution with complexity <code class="language-plaintext highlighter-rouge">n * n</code> for an input size of <code class="language-plaintext highlighter-rouge">10 000</code> is not even worth writing, while <code class="language-plaintext highlighter-rouge">n * logn</code> is fine</p>
    </blockquote>
  </li>
  <li><strong>even simple arithmetic operations can be saved</strong>
    <blockquote>
      <p>for example, if suddenly within a loop you repeatedly step to elements at some distance, for example <code class="language-plaintext highlighter-rouge">d ** 3</code>, then by storing this value at each iteration in the <code class="language-plaintext highlighter-rouge">shift</code> variable, you can significantly speed up the program</p>
    </blockquote>
  </li>
  <li><strong>iterating over rows and columns in a matrix, if they are represented by a list of lists, is not the same thing</strong>
    <blockquote>
      <p>yes, this is quite a basic rule, but once in an asymptotically optimal solution I ran into this, and for a long time I could not understand what solution the authors of the problem expected from me… the reason for this phenomenon is the physical arrangement of array memory elements and random access speed</p>
    </blockquote>
  </li>
</ul>]]></content><author><name></name></author><category term="code," /><category term="algorithms," /><category term="contest" /><summary type="html"><![CDATA[general conclusions after participating in the contest]]></summary></entry></feed>