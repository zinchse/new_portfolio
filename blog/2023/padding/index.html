<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Why is understanding the physical implementation of memory useful? | Sergey E. Zinchenko</title>
    <meta name="author" content="Sergey E. Zinchenko">
    <meta name="description" content="From data compression to padding and Bloom's filter">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://zinchse.github.io/blog/2023/padding/">
    
    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Sergey </span>E. Zinchenko</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">about</a>
              </li>
              
              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">cv</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Why is understanding the physical implementation of memory useful?</h1>
    <p class="post-meta">September 2, 2023</p>
    <p class="post-tags">
      <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>
        ·  
        <a href="/blog/category/architecture">
          <i class="fas fa-tag fa-sm"></i> architecture,</a>  
          <a href="/blog/category/algorithms">
          <i class="fas fa-tag fa-sm"></i> algorithms</a>  
          

    </p>
  </header>

  <article class="post-content">
    <h1 id="data-compression">Data compression</h1>

<p>I recently <a href="https://zinchse.github.io/blog/2023/yandex-training/">[talked]</a> about the moment when <code class="language-plaintext highlighter-rouge">Yandex.Trainings</code> put me on the spot. The last problem in this contest can be reduced to a BFS on a state graph. I got into it in a minute, spent two more on the code. And? My first submit got <code class="language-plaintext highlighter-rouge">MLE</code> (memory limit error). I thought: “Okay, I’ll fix it”. I optimized the code and… I got MLE again! On a different test, but there is no difference. All the time of the contest I was beating myself up over it, thinking: “What the hell is this?”. But it didn’t work. I guess sometimes even I can be wrong…</p>

<p>A couple months after that, I went back to the task, looked at it with fresh eyes and came to the conclusion that I was doing everything right! Mostly the task was passed in C++, and few people had encountered this problem. But by chance I still came across a <code class="language-plaintext highlighter-rouge">.py</code> solution that passed all the tests! And it implemented exactly what I tried, except for one thing. The only thing that made the solution different was that the description of a vertex of the state graph was compressed from a tuple to a <strong>single integer</strong>. It is conceptually <strong>impossible</strong> to describe a graph vertex with less than 3 numbers. However, given that each of these three numbers is guaranteed to be in a known small range, it is possible to encode all numbers with one! In fact, this approach exploits an interesting feature of the hardware:</p>

<div align="center">
<i>No matter how large a number is stored in a variable, physically it always occupies a certain space!</i>
</div>

<p><br>
<em>And how we can use it?</em> Let’s take a look… <br>
Suppose we have numbers \(a\) and \(b\), each of which is in the range \([0; \, 10^d - 1]\). Then both of these numbers can be represented by a single number \(z\) as follows \(z = zip(a, b) = a \cdot 10 ^ {d} + b\). If \(d=2\), \(a=1\) and \(b=12\), then \(z=zip(a, b) = 112\). By the number \(z\) we can always recover \(a\) and \(b\) as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">unzip</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">z</span> <span class="o">//</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">z</span> <span class="o">%</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="n">d</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
</code></pre></div></div>

<figure>
    <div style="text-align:center;">
        <img src="/assets/img/zip_example.png" alt="alignment example" width="450px">
        <figcaption>
            An example of compressing two integers into one 
            <br>
            due to a large number of non-significant zeros.
        </figcaption>
    </div>
</figure>

<p>Although asymptotically the occupied memory remains the same, at large sizes the savings of even a factor of constant can be extremely noticeable!</p>

<p>*note that we assume all numbers are positive, otherwise we would need an extra bit.</p>

<h1 id="padding">Padding</h1>

<p>Now we has convinced that studying the features of physical storage of objects in memory can be useful. However, now we will get acquainted with an even more interesting technique.</p>

<p>In the real world, the hardware reads several consecutive bytes (often 4) at once on each read operation. Moreover, on a number of architectures, it can only read 4 bytes from a position that is a multiple of 4. That is (<em>when indexing bytes from 1</em>), on some architectures it is basically <strong>impossible to read bytes [2-5] at a time</strong>. In this case, if we want to store an integer of size 4 bytes, the most efficient way to store it is to place it in consecutive 4 bytes starting at a multiple of 4. Why? Because it’s the only way we can read all the bytes of a number, spending <em>only 1 read operation</em> (see picture below). Any other way of storing information would take more! And the most efficient way to store a \(b\) byte number is to arrange it starting at the byte whose number is a multiple of \(b\) (the reason for this phenomenon is already very technical and we will omit it). Arranging objects so that they satisfy this condition is called <strong>alignment</strong>.</p>

<figure>
    <div style="text-align:center;">
        <img src="/assets/img/alignment_example.png" alt="alignment example" width="450px">
        <figcaption>
            An example of where additional read operations
            <br>
             may be required if bytes are misaligned.
        </figcaption>
    </div>
</figure>

<p>Okay, easy and simple. Although… Stop! What should we do with structures whose fields have different sizes? The requirements for their alignment are <strong>different</strong> and we can’t store the fields right behind each other. To combat this, we will have to use <strong>padding</strong> technique. This consists of a) locating the beginning of the structure in a byte whose address is a multiple of the size of the largest field in the structure and b) keeping all fields aligned by introducing “garbage” bytes if necessary.</p>

<p><strong>Example</strong></p>

<p>Suppose we have a <code class="language-plaintext highlighter-rouge">MyStruct</code> structure with <code class="language-plaintext highlighter-rouge">char</code> and <code class="language-plaintext highlighter-rouge">int</code> fields. The first field must be located starting from the byte divisible by 4 (because of the peculiarities of reading by quadruples). But the second field can’t follow it because of its alignment requirement! So we have to leave 3 bytes empty! That is, we only use 5 bytes, but take up 8.  As much as 37.5% of the allocated space is garbage! Knowing this can be useful, because by rearranging the fields we can compress the space occupied by the structure! Why this is so - see example below.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">MyStruct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">my_char</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<figure>
    <div style="text-align:center;">
        <img src="/assets/img/padding_example.png" alt="alignment example" width="450px">
        <figcaption>
            An example of how the allocation of extra bytes can be used
            <br>
             to efficiently store fields of complex structure.
        </figcaption>
    </div>
</figure>

<p><strong>Example</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># the size of this structure is 12 bytes
</span><span class="k">struct</span> <span class="nc">MyLargeStruct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">first_char</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">second_char</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp"># but the size of this structure is only 8 bytes
</span><span class="k">struct</span> <span class="nc">MySmallStruct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">first_char</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">second_char</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>For the <code class="language-plaintext highlighter-rouge">MyLargeStruct</code> structure, we need as many as 6 additional padding bytes! The first 3 are for aligning the <code class="language-plaintext highlighter-rouge">value</code> field on a multiple of 4. But besides that we need 3 bytes after the last <code class="language-plaintext highlighter-rouge">char</code>. Why? It’s not so trivial anymore. Suppose we want to create an array with elements of this structure. To support field alignment of all objects at once and easy addressing, it is very convenient to keep the size of the structure divisible to the size of its largest field. In our case, the size of the largest field is 4, and we have to add 3 bytes of alignment at the end. But for <code class="language-plaintext highlighter-rouge">MyStructSmall</code>, we only need 2 bytes of padding at the end of it. That is, just by rearranging the order of the fields, we took 3 times less additional bytes!</p>

<h1 id="bloom-filter">Bloom filter</h1>

<p>Even with the most efficient data arrangement, in some cases we will have unused memory space due to the hardware architecture. This means that we can occupy it with something useful! For example, add new fields in those places that will be occupied anyway.</p>

<figure>
    <div style="text-align:center;">
        <img src="/assets/img/bloom_example.png" alt="alignment example" width="450px">
        <figcaption>
            Knowledge about physical data storage can be used to improve
            <br>
            the efficiency of an algorithm. For example, we can add new
            <br>
            fields in places where padding will be used anyway.
        </figcaption>
    </div>
</figure>

<p>In practice I faced such a situation when fields of my structure were hash values of some object. My structures were often used for expensive comparison of objects, which was often avoided by hash matching check. By introducing fields with the values of other hash functions, I was able to significantly reduce collisions. In fact, I turned my comparison algorithm into something very similar to the Bloom filter. This <strong>improved</strong> my system performance, and <strong>I didn’t waste a single byte of extra space</strong> !</p>

<p>Some might argue: “Why would You go off in the direction of the Bloom filter? Ok, You have more space, take a more complex hash function. You might even have fewer collisions with it!”. Yeah. Thanks for the idea, but for backward compatibility, I had to leave the previous field as it is. That’s the main beauty of this approach - with the help of memory management knowledge You can <strong>add new functionality</strong> to Your structure <strong>without any overhead and consequences</strong>!</p>

<h1 id="conclusion">Conclusion</h1>

<div align="center">
<i>Knowledge is power and failures can be turned into useful lessons :)</i>
</div>

  </article>


  
    
    <br>
    <hr>
    <br>
    <ul class="list-disc pl-8"></ul>

    <!-- Adds related posts to the end of an article -->
    <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2>
    <p class="mb-2">Here are some more articles you might like to read next:</p>
  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/leetcode-challenge/">Leetcode Marathon (**do not repeat!**)</a>
  </li>

  

  <li class="my-2">
    <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/yandex-training/">Yandex Training 3.0 - Hints and Results</a>
  </li>

<div id="disqus_thread" style="max-width: 600px; margin: 0 auto;">
    <script type="text/javascript">
        var disqus_shortname  = 'al-folio';
        var disqus_identifier = '/blog/2023/padding';
        var disqus_title      = "Why is understanding the physical implementation of memory useful?";
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by Disqus.</a>
</noscript>
</div>
</div>

    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2023 Sergey E. Zinchenko. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>.
Last updated: September 23, 2023.
      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
